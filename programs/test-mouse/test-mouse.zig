const std = @import("std");
const georgios = @import("georgios");
comptime {_ = georgios;}

const I32Point = georgios.utils.I32Point;
const U32Point = georgios.utils.U32Point;
const system_calls = georgios.system_calls;

const console = georgios.get_console_writer();
const esc = "\x1b";
const reset_console = esc ++ "c";
const ansi_esc = esc ++ "[";
const invert_colors = ansi_esc ++ "7m";

var vbe: bool = undefined;
var scale: u16 = undefined;
var screen = U32Point{};
var last_pos = U32Point{};
var pos = U32Point{};
var last_delta = I32Point{};
var buttons = [_]bool{false} ** 3;

fn draw_at(p: U32Point, comptime fmt: []const u8, args: anytype) void {
    try console.print(ansi_esc ++ "{};{}H", .{p.y / scale, p.x / scale});
    try console.print(fmt, args);
}

const vbe_cursor = U32Point{.x = 4, .y = 4};
var vbe_index: u8 = 0;

// import math
// for i, n in enumerate([int(math.sin(i / 255 * 2 * math.pi) * 128 + 127) for i in range(0, 256)]):
//     if (i % 8 == 0):
//         print()
//     print('0x{:02x}, '.format(n), end='')
// print()
const sin = [_]u8 {
    0x7f, 0x82, 0x85, 0x88, 0x8b, 0x8e, 0x91, 0x94,
    0x98, 0x9b, 0x9e, 0xa1, 0xa4, 0xa7, 0xaa, 0xad,
    0xb0, 0xb3, 0xb5, 0xb8, 0xbb, 0xbe, 0xc1, 0xc3,
    0xc6, 0xc8, 0xcb, 0xce, 0xd0, 0xd2, 0xd5, 0xd7,
    0xd9, 0xdb, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe7,
    0xe9, 0xeb, 0xed, 0xee, 0xf0, 0xf1, 0xf2, 0xf4,
    0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc,
    0xfc, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
    0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfd, 0xfd, 0xfc,
    0xfc, 0xfb, 0xfa, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6,
    0xf4, 0xf3, 0xf2, 0xf0, 0xef, 0xed, 0xec, 0xea,
    0xe8, 0xe7, 0xe5, 0xe3, 0xe1, 0xdf, 0xdd, 0xda,
    0xd8, 0xd6, 0xd4, 0xd1, 0xcf, 0xcc, 0xca, 0xc7,
    0xc5, 0xc2, 0xbf, 0xbc, 0xba, 0xb7, 0xb4, 0xb1,
    0xae, 0xab, 0xa8, 0xa5, 0xa2, 0x9f, 0x9c, 0x99,
    0x96, 0x93, 0x90, 0x8d, 0x8a, 0x86, 0x83, 0x80,
    0x7d, 0x7a, 0x77, 0x73, 0x70, 0x6d, 0x6a, 0x67,
    0x64, 0x61, 0x5e, 0x5b, 0x58, 0x55, 0x52, 0x4f,
    0x4c, 0x49, 0x46, 0x43, 0x41, 0x3e, 0x3b, 0x38,
    0x36, 0x33, 0x31, 0x2e, 0x2c, 0x29, 0x27, 0x25,
    0x23, 0x20, 0x1e, 0x1c, 0x1a, 0x18, 0x16, 0x15,
    0x13, 0x11, 0x10, 0x0e, 0x0d, 0x0b, 0x0a, 0x09,
    0x07, 0x06, 0x05, 0x04, 0x03, 0x03, 0x02, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0b, 0x0c, 0x0d, 0x0f, 0x10, 0x12, 0x14,
    0x16, 0x17, 0x19, 0x1b, 0x1d, 0x1f, 0x22, 0x24,
    0x26, 0x28, 0x2b, 0x2d, 0x2f, 0x32, 0x35, 0x37,
    0x3a, 0x3c, 0x3f, 0x42, 0x45, 0x48, 0x4a, 0x4d,
    0x50, 0x53, 0x56, 0x59, 0x5c, 0x5f, 0x62, 0x65,
    0x69, 0x6c, 0x6f, 0x72, 0x75, 0x78, 0x7b, 0x7e,
};
const cos = [_]u8 {
    0xff, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfd, 0xfd,
    0xfc, 0xfb, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6,
    0xf5, 0xf3, 0xf2, 0xf1, 0xef, 0xee, 0xec, 0xea,
    0xe9, 0xe7, 0xe5, 0xe3, 0xe1, 0xdf, 0xdd, 0xdb,
    0xd9, 0xd6, 0xd4, 0xd2, 0xcf, 0xcd, 0xca, 0xc8,
    0xc5, 0xc3, 0xc0, 0xbd, 0xba, 0xb8, 0xb5, 0xb2,
    0xaf, 0xac, 0xa9, 0xa6, 0xa3, 0xa0, 0x9d, 0x9a,
    0x97, 0x94, 0x91, 0x8d, 0x8a, 0x87, 0x84, 0x81,
    0x7e, 0x7b, 0x77, 0x74, 0x71, 0x6e, 0x6b, 0x68,
    0x65, 0x62, 0x5f, 0x5b, 0x58, 0x55, 0x52, 0x50,
    0x4d, 0x4a, 0x47, 0x44, 0x41, 0x3f, 0x3c, 0x39,
    0x36, 0x34, 0x31, 0x2f, 0x2c, 0x2a, 0x28, 0x25,
    0x23, 0x21, 0x1f, 0x1d, 0x1b, 0x19, 0x17, 0x15,
    0x13, 0x12, 0x10, 0x0e, 0x0d, 0x0c, 0x0a, 0x09,
    0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01,
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
    0x09, 0x0a, 0x0c, 0x0d, 0x0e, 0x10, 0x12, 0x13,
    0x15, 0x17, 0x19, 0x1b, 0x1d, 0x1f, 0x21, 0x23,
    0x25, 0x28, 0x2a, 0x2c, 0x2f, 0x31, 0x34, 0x36,
    0x39, 0x3c, 0x3e, 0x41, 0x44, 0x47, 0x4a, 0x4d,
    0x50, 0x52, 0x55, 0x58, 0x5b, 0x5f, 0x62, 0x65,
    0x68, 0x6b, 0x6e, 0x71, 0x74, 0x77, 0x7b, 0x7e,
    0x81, 0x84, 0x87, 0x8a, 0x8d, 0x91, 0x94, 0x97,
    0x9a, 0x9d, 0xa0, 0xa3, 0xa6, 0xa9, 0xac, 0xaf,
    0xb2, 0xb5, 0xb8, 0xba, 0xbd, 0xc0, 0xc3, 0xc5,
    0xc8, 0xca, 0xcd, 0xcf, 0xd2, 0xd4, 0xd6, 0xd9,
    0xdb, 0xdd, 0xdf, 0xe1, 0xe3, 0xe5, 0xe7, 0xe9,
    0xea, 0xec, 0xee, 0xef, 0xf1, 0xf2, 0xf3, 0xf5,
    0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfb, 0xfc,
    0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff,
};

fn draw_cursor(e: *const georgios.MouseEvent) void {
    if (vbe) {
        vbe_index +%= 1;
        const ri = vbe_index +% @intCast(u8, @boolToInt(e.lmb_pressed)) * 128;
        const gi = vbe_index +% @intCast(u8, @boolToInt(e.mmb_pressed)) * 128;
        const bi = vbe_index +% @intCast(u8, @boolToInt(e.rmb_pressed)) * 128;
        system_calls.vbe_fill_rect(&.{.size = vbe_cursor, .pos = pos},
            (@intCast(u32, sin[ri]) << 16) | (@intCast(u32, cos[gi]) << 8) | bi | 0xff000000);
    } else {
        var char: u8 = ' ';
        if (e.lmb_pressed) {
            char = 'L';
        } else if (e.mmb_pressed) {
            char = 'M';
        } else if (e.rmb_pressed) {
            char = 'R';
        }
        draw_at(last_pos, "{c}", .{char});
        draw_at(pos, "{s}{c}{s}", .{invert_colors, char, invert_colors});
    }
    last_pos = pos;
}

fn draw_status() void {
    if (vbe) return; // TODO: Way too slow right now
    const pressed = [_][]const u8{invert_colors, invert_colors};
    const not = [_][]const u8{"", ""};
    const lmb: []const []const u8 = if (buttons[0]) pressed[0..] else not[0..];
    const mmb: []const []const u8 = if (buttons[1]) pressed[0..] else not[0..];
    const rmb: []const []const u8 = if (buttons[2]) pressed[0..] else not[0..];
    draw_at(.{.y = screen.y + scale},
        "[{s}L{s}]({s}M{s})[{s}R{s}] x = {} ({}), y = {} ({})        ", .{
        lmb[0], lmb[1], mmb[0], mmb[1], rmb[0], rmb[1],
        pos.x, last_delta.x, pos.y, last_delta.y});
}

fn mouse_move(axis: *u32, delta: i32, max: u32) i32 {
    const signed_max = @intCast(i32, max);
    var r: i32 = 0;
    if (@addWithOverflow(i32, @intCast(i32, axis.*), delta, &r)) {
        r = if (delta > 0) signed_max else 0;
    }
    if (r < 0) r = 0;
    if (r > signed_max) r = signed_max;
    axis.* = @intCast(u32, r);
    return delta;
}

fn reset() void {
    try console.print(reset_console ++ ansi_esc ++ "25l", .{});
    if (system_calls.vbe_res()) |vbe_res| {
        vbe = true;
        scale = 1;
        screen = vbe_res;
    } else {
        vbe = false;
        scale = 16;
        screen = .{.x = system_calls.console_width() - 1, .y = system_calls.console_height() - 2};
    }
    screen = screen.multiply(scale);
    pos = screen.divide(2);
    draw_status();
}

pub fn main() void {
    reset();
    while (true) {
        if (system_calls.get_key(.NonBlocking)) |e| {
            if (e.kind == .Pressed) {
                if (e.unshifted_key == .Key_Escape) {
                    break;
                } if (e.unshifted_key == .Key_Delete) {
                    reset();
                }
            }
        }
        if (system_calls.get_mouse_event(.NonBlocking)) |e| {
            last_delta = .{
                .x = mouse_move(&pos.x, e.delta.x, screen.x),
                .y = mouse_move(&pos.y, -e.delta.y, screen.y),
            };
            buttons[0] = e.lmb_pressed;
            buttons[1] = e.mmb_pressed;
            buttons[2] = e.rmb_pressed;
            if (!last_pos.eq(pos)) {
                draw_cursor(&e);
            }
            draw_status();
        }
        system_calls.sleep_milliseconds(5);
    }
    try console.print(reset_console, .{});
}
